{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar AudioSpectrum = function (_Component) {\n  _inherits(AudioSpectrum, _Component);\n\n  function AudioSpectrum(props) {\n    _classCallCheck(this, AudioSpectrum);\n\n    var _this = _possibleConstructorReturn(this, (AudioSpectrum.__proto__ || Object.getPrototypeOf(AudioSpectrum)).call(this, props));\n\n    _this.initAudioEvents = function (analyser) {\n      var audioEle = _this.audioEle;\n\n      audioEle.onpause = function (e) {\n        _this.playStatus = 'PAUSED';\n      };\n\n      audioEle.onplay = function (e) {\n        _this.playStatus = 'PLAYING';\n\n        _this.drawSpectrum(analyser);\n      };\n    };\n\n    _this.drawSpectrum = function (analyser) {\n      var cwidth = _this.audioCanvas.width;\n      var cheight = _this.audioCanvas.height - _this.props.capHeight;\n      var capYPositionArray = []; // store the vertical position of hte caps for the preivous frame\n\n      var ctx = _this.audioCanvas.getContext('2d');\n\n      var gradient = ctx.createLinearGradient(0, 0, 0, 300);\n\n      if (_this.props.meterColor.constructor === Array) {\n        var stops = _this.props.meterColor;\n        var len = stops.length;\n\n        for (var i = 0; i < len; i++) {\n          gradient.addColorStop(stops[i]['stop'], stops[i]['color']);\n        }\n      } else if (typeof _this.props.meterColor === 'string') {\n        gradient = _this.props.meterColor;\n      }\n\n      var drawMeter = function drawMeter() {\n        var array = new Uint8Array(analyser.frequencyBinCount); // item value of array: 0 - 255\n\n        analyser.getByteFrequencyData(array);\n\n        if (_this.playStatus === 'PAUSED') {\n          for (var _i = array.length - 1; _i >= 0; _i--) {\n            array[_i] = 0;\n          }\n\n          var allCapsReachBottom = !capYPositionArray.some(function (cap) {\n            return cap > 0;\n          });\n\n          if (allCapsReachBottom) {\n            ctx.clearRect(0, 0, cwidth, cheight + _this.props.capHeight);\n            cancelAnimationFrame(_this.animationId); // since the sound is top and animation finished, stop the requestAnimation to prevent potential memory leak,THIS IS VERY IMPORTANT!\n\n            return;\n          }\n        }\n\n        var step = Math.round(array.length / _this.props.meterCount); // sample limited data from the total array\n\n        ctx.clearRect(0, 0, cwidth, cheight + _this.props.capHeight);\n\n        for (var _i2 = 0; _i2 < _this.props.meterCount; _i2++) {\n          var value = array[_i2 * step];\n\n          if (capYPositionArray.length < Math.round(_this.props.meterCount)) {\n            capYPositionArray.push(value);\n          }\n\n          ;\n          ctx.fillStyle = _this.props.capColor; // draw the cap, with transition effect\n\n          if (value < capYPositionArray[_i2]) {\n            // let y = cheight - (--capYPositionArray[i])\n            var preValue = --capYPositionArray[_i2];\n\n            var _y = (270 - preValue) * cheight / 270;\n\n            ctx.fillRect(_i2 * (_this.props.meterWidth + _this.props.gap), _y, _this.props.meterWidth, _this.props.capHeight);\n          } else {\n            // let y = cheight - value\n            var _y2 = (270 - value) * cheight / 270;\n\n            ctx.fillRect(_i2 * (_this.props.meterWidth + _this.props.gap), _y2, _this.props.meterWidth, _this.props.capHeight);\n            capYPositionArray[_i2] = value;\n          }\n\n          ;\n          ctx.fillStyle = gradient; // set the filllStyle to gradient for a better look\n          // let y = cheight - value + this.props.capHeight\n\n          var y = (270 - value) * cheight / 270 + _this.props.capHeight;\n          ctx.fillRect(_i2 * (_this.props.meterWidth + _this.props.gap), y, _this.props.meterWidth, cheight); // the meter\n        }\n\n        _this.animationId = requestAnimationFrame(drawMeter);\n      };\n\n      _this.animationId = requestAnimationFrame(drawMeter);\n    };\n\n    _this.setupAudioNode = function (audioEle) {\n      var analyser = _this.audioContext.createAnalyser();\n\n      analyser.smoothingTimeConstant = 0.8;\n      analyser.fftSize = 2048;\n\n      var mediaEleSource = _this.audioContext.createMediaElementSource(audioEle);\n\n      mediaEleSource.connect(analyser);\n      mediaEleSource.connect(_this.audioContext.destination);\n      return analyser;\n    };\n\n    _this.prepareElements = function () {\n      _this.audioEle = document.getElementById(_this.props.audioId);\n      _this.audioCanvas = document.getElementById(_this.canvasId);\n    };\n\n    _this.prepareAPIs = function () {\n      // fix browser vender for AudioContext and requestAnimationFrame\n      window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext;\n      window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;\n      window.cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame;\n\n      try {\n        _this.audioContext = new AudioContext(); // 1.set audioContext\n      } catch (e) {\n        // console.error('!Your browser does not support AudioContext')\n        console.log(e);\n      }\n    };\n\n    _this.animationId = null;\n    _this.audioContext = null;\n    _this.audioEle = null;\n    _this.audioCanvas = null;\n    _this.playStatus = null;\n    _this.canvasId = _this.props.id || _this.getRandomId(50);\n    return _this;\n  }\n\n  _createClass(AudioSpectrum, [{\n    key: 'getRandomId',\n    value: function getRandomId(len) {\n      var str = '1234567890-qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM';\n      var strLen = str.length;\n      var res = '';\n\n      for (var i = 0; i < len; i++) {\n        var randomIndex = Math.floor(Math.random() * strLen);\n        res += str[randomIndex];\n      }\n\n      return res;\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.prepareAPIs();\n      this.prepareElements();\n      var analyser = this.setupAudioNode(this.audioEle);\n      this.initAudioEvents(analyser);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement('canvas', {\n        id: this.canvasId,\n        width: this.props.width,\n        height: this.props.height\n      });\n    }\n  }]);\n\n  return AudioSpectrum;\n}(_react.Component);\n\nAudioSpectrum.propTypes = {\n  id: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),\n  width: _propTypes2.default.number,\n  height: _propTypes2.default.number,\n  audioId: _propTypes2.default.string.isRequired,\n  capColor: _propTypes2.default.string,\n  capHeight: _propTypes2.default.number,\n  meterWidth: _propTypes2.default.number,\n  meterCount: _propTypes2.default.number,\n  meterColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    stop: _propTypes2.default.number,\n    color: _propTypes2.default.string\n  }))]),\n  gap: _propTypes2.default.number\n};\nAudioSpectrum.defaultProps = {\n  width: 300,\n  height: 200,\n  capColor: '#FFF',\n  capHeight: 2,\n  meterWidth: 2,\n  meterCount: 40 * (2 + 2),\n  meterColor: [{\n    stop: 0,\n    color: '#f00'\n  }, {\n    stop: 0.5,\n    color: '#0CD7FD'\n  }, {\n    stop: 1,\n    color: 'red'\n  }],\n  gap: 10 // gap between meters\n\n};\nexports.default = AudioSpectrum;","map":null,"metadata":{},"sourceType":"script"}